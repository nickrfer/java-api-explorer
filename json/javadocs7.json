{"types":["{\"name\":\"javax/lang/model/util/AbstractAnnotationValueVisitor7\",\"fullType\":\"\",\"packageName\":\"javax.lang.model.util\",\"description\":\"@SupportedSourceVersion(value=RELEASE_7)\\npublic abstract class AbstractAnnotationValueVisitor7<R,P>\\nextends AbstractAnnotationValueVisitor6<R,P>\",\"path\":\"https://docs.oracle.com/javase/7/docs/api/javax/lang/model/util/AbstractAnnotationValueVisitor7.html\",\"newType\":true}","{\"name\":\"javax/lang/model/util/AbstractElementVisitor7\",\"fullType\":\"\",\"packageName\":\"javax.lang.model.util\",\"description\":\"@SupportedSourceVersion(value=RELEASE_7)\\npublic abstract class AbstractElementVisitor7<R,P>\\nextends AbstractElementVisitor6<R,P>\",\"path\":\"https://docs.oracle.com/javase/7/docs/api/javax/lang/model/util/AbstractElementVisitor7.html\",\"newType\":true}","{\"name\":\"java/util/concurrent/locks/AbstractQueuedLongSynchronizer\",\"fullType\":\"\",\"packageName\":\"java.util.concurrent.locks\",\"description\":\"public abstract class AbstractQueuedLongSynchronizer\\nextends AbstractOwnableSynchronizer\\nimplements Serializable\",\"path\":\"https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/AbstractQueuedLongSynchronizer.html\",\"newType\":false}","{\"name\":\"java/util/concurrent/locks/AbstractQueuedSynchronizer\",\"fullType\":\"\",\"packageName\":\"java.util.concurrent.locks\",\"description\":\"public abstract class AbstractQueuedSynchronizer\\nextends AbstractOwnableSynchronizer\\nimplements Serializable\\n Acquire:\\n     while (!tryAcquire(arg)) {\\n        enqueue thread if it is not already queued;\\n        possibly block current thread;\\n     }\\n\\n Release:\\n     if (tryRelease(arg))\\n        unblock the first queued thread;\\n \\n class Mutex implements Lock, java.io.Serializable {\\n\\n   // Our internal helper class\\n   private static class Sync extends AbstractQueuedSynchronizer {\\n     // Report whether in locked state\\n     protected boolean isHeldExclusively() {\\n       return getState() == 1;\\n     }\\n\\n     // Acquire the lock if state is zero\\n     public boolean tryAcquire(int acquires) {\\n       assert acquires == 1; // Otherwise unused\\n       if (compareAndSetState(0, 1)) {\\n         setExclusiveOwnerThread(Thread.currentThread());\\n         return true;\\n       }\\n       return false;\\n     }\\n\\n     // Release the lock by setting state to zero\\n     protected boolean tryRelease(int releases) {\\n       assert releases == 1; // Otherwise unused\\n       if (getState() == 0) throw new IllegalMonitorStateException();\\n       setExclusiveOwnerThread(null);\\n       setState(0);\\n       return true;\\n     }\\n\\n     // Provide a Condition\\n     Condition newCondition() { return new ConditionObject(); }\\n\\n     // Deserialize properly\\n     private void readObject(ObjectInputStream s)\\n         throws IOException, ClassNotFoundException {\\n       s.defaultReadObject();\\n       setState(0); // reset to unlocked state\\n     }\\n   }\\n\\n   // The sync object does all the hard work. We just forward to it.\\n   private final Sync sync = new Sync();\\n\\n   public void lock()                { sync.acquire(1); }\\n   public boolean tryLock()          { return sync.tryAcquire(1); }\\n   public void unlock()              { sync.release(1); }\\n   public Condition newCondition()   { return sync.newCondition(); }\\n   public boolean isLocked()         { return sync.isHeldExclusively(); }\\n   public boolean hasQueuedThreads() { return sync.hasQueuedThreads(); }\\n   public void lockInterruptibly() throws InterruptedException {\\n     sync.acquireInterruptibly(1);\\n   }\\n   public boolean tryLock(long timeout, TimeUnit unit)\\n       throws InterruptedException {\\n     return sync.tryAcquireNanos(1, unit.toNanos(timeout));\\n   }\\n }\\n \\n class BooleanLatch {\\n\\n   private static class Sync extends AbstractQueuedSynchronizer {\\n     boolean isSignalled() { return getState() != 0; }\\n\\n     protected int tryAcquireShared(int ignore) {\\n       return isSignalled() ? 1 : -1;\\n     }\\n\\n     protected boolean tryReleaseShared(int ignore) {\\n       setState(1);\\n       return true;\\n     }\\n   }\\n\\n   private final Sync sync = new Sync();\\n   public boolean isSignalled() { return sync.isSignalled(); }\\n   public void signal()         { sync.releaseShared(1); }\\n   public void await() throws InterruptedException {\\n     sync.acquireSharedInterruptibly(1);\\n   }\\n }\\n \",\"path\":\"https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/AbstractQueuedSynchronizer.html\",\"newType\":false}"]}
